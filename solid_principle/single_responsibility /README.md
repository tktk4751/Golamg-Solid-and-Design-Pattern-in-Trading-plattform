

## 単一責任の原則

### TL;DR

1つのクラスは､1つの使用者に対して存在するべきである｡
1つの使用者が負う以上の責務をそのクラスには書かないこと｡
全く同じロジックであっても､使用者や概念が異なれば､分けて記載すること｡


### Copilotによるわかりやすい解説

プロンプト:
SOLID原則の単一責任の原則について､小学生でもわかるように､丁寧にわかりやすく解説してください｡なぜ必要なのか､どのように実装するのか､どんなシーンで取り入れるべきか?を教えてください｡サンプルコードを書く場合は､Go言語で書いてください｡


回答:
もちろんです！SOLID原則の中の「単一責任の原則」（Single Responsibility Principle, SRP）について説明しますね。

まず、SRPとは何かを理解するために、小学生が学校で経験することを例に考えてみましょう。学校では、先生がそれぞれ異なる科目を教えていますよね。数学の先生は数学を、国語の先生は国語を教えます。これは、それぞれの先生が「単一の責任」を持っていると言えます。数学の先生が音楽も教えるとなると、その先生は二つの全く異なる科目を教える責任を負うことになり、それぞれの科目に十分な時間を割くことが難しくなるかもしれません。

これと同じように、プログラミングにおける「単一責任の原則」は、一つのクラスや関数が一つの責任だけを持つべきだという考え方です。これにより、コードの見通しが良くなり、保守性や再利用性が向上します。

では、Go言語での具体的な実装例を見てみましょう。以下に、`Calculator`という構造体と、その中に`Add`と`Subtract`という二つのメソッドを持つコードを示します。

```go
type Calculator struct{}

func (c Calculator) Add(a int, b int) int {
    return a + b
}

func (c Calculator) Subtract(a int, b int) int {
    return a - b
}
```

しかし、この`Calculator`は加算と減算の二つの責任を持っています。単一責任の原則に従うと、それぞれの操作を行うための別々の構造体を作成するべきです。

```go
type Adder struct{}

func (a Adder) Add(a int, b int) int {
    return a + b
}

type Subtractor struct{}

func (s Subtractor) Subtract(a int, b int) int {
    return a - b
}
```

このように、単一責任の原則を適用することで、各構造体とそのメソッドは一つの明確な責任を持つようになりました。これにより、コードの見通しが良くなり、保守性や再利用性が向上します。

この原則は、新しい機能を追加する際や既存の機能を修正する際に特に役立ちます。一つのクラスや関数が一つの責任だけを持っている場合、そのクラスや関数が影響を受けるのはその責任に関連する変更だけになるため、予期しない副作用を減らすことができます。

以上が、単一責任の原則の基本的な説明となります。この原則を理解し、適切に適用することで、より良いソフトウェアを開発することができます。

### まとめ

単一責任の原則を守るためにも､クラスを設計する前に､予めインターフェイスの定義を考えるべきだというのが､現段階での所感｡

インターフェイスでクラスの振る舞いを明確にした上でクラスを設計するほうが､スッキリとクラスを設計できそうだ｡

Copilotの例えの学校の先生の例は聡明だ｡
数学の先生は､"数学を教える"という責務を果たすということを最初に明確にしておくことで､音楽を教えてくれないか?という意味不明な誘いに惑わされなくなるだろう｡

**クラスが果たすべき責任を､最初にインターフェイスで定義してからクラスを設計しよう｡**
