

## オープンクローズドの原則

### TL;DR
機能の追加は､既存のコードを変更するのではなく､新しいコードを追加することで実装するべき
機能を拡張した際に､変更する箇所がほぼ発生しないように設計をすること
それは､各クラスがインターフェイスに依存することによって達成できる


Copilotによるわかりやすい解説

プロンプト:
SOLID原則のオープンクローズドの原則について､小学生でもわかるように､丁寧にわかりやすく解説してください｡なぜ必要なのか､どのように実装するのか､どんなシーンで取り入れるべきか?を教えてください｡サンプルコードを書く場合は､Go言語で書いてください｡

回答:
もちろんです！SOLID原則の中の「オープン・クローズド原則」について、小学生でもわかるように説明しますね。

まず、オープン・クローズド原則とは何かを理解するために、おもちゃの箱を想像してみてください。この箱は「オープン」で、新しいおもちゃを追加することができます。しかし、一度入れたおもちゃは「クローズド」で、それ自体は変更できません。これがオープン・クローズド原則の基本的な考え方です。

この原則は、ソフトウェアの設計において、クラスやモジュールが新しい機能に対して「オープン」であるべきだが、既存のコードの修正に対しては「クローズド」であるべきだという考え方を示しています。つまり、新しい機能を追加するために既存のコードを変更するのではなく、新しいコードを追加することで機能を拡張できるようにするべきだということです。

では、なぜこの原則が必要なのでしょうか。それは、既存のコードを変更すると、そのコードが既に動作している他の部分に予期しない影響を及ぼす可能性があるからです。この原則を守ることで、新しい機能を安全に追加し、既存の機能を壊すリスクを減らすことができます。

次に、どのように実装するのか、そしてどんなシーンで取り入れるべきかについてですが、これは具体的な設計や要件によります。しかし、一般的には、新しい機能を追加する必要があり、既存のコードを変更することなくそれを達成したい場合にこの原則を適用します。

Go言語でのサンプルコードを以下に示します。このコードでは、`Greeter`インターフェースが定義され、新しい挨拶方法を追加するためには新しい型を作成し、その型で`Greeter`インターフェースを実装します。これにより、`Greet`関数は変更されずに新しい挨拶方法を追加することができます。

```go
package main

import "fmt"

// Greeter インターフェース
type Greeter interface {
	Greet() string
}

// English は英語の挨拶を返す
type English struct{}

func (e English) Greet() string {
	return "Hello!"
}

// Spanish はスペイン語の挨拶を返す
type Spanish struct{}

func (s Spanish) Greet() string {
	return "¡Hola!"
}

// Greet 関数は挨拶を行う
func Greet(g Greeter) {
	fmt.Println(g.Greet())
}

func main() {
	Greet(English{})
	Greet(Spanish{})
}
```

このように、オープン・クローズド原則を理解し、適切に適用することで、ソフトウェアの設計と保守がより容易になります。この原則が役立つことを願っています！


### まとめ
依存先はインターフェイスにしよう｡別のクラスに依存するのは絶対NG｡
